# Java最佳实践

用自己话讲一遍知识，用自己的知识形成最佳实践

## 基础（特性、数据类型、反射、序列化、枚举、注解、泛型、拆装箱、数值处理等）

- 面向过程是过程化的编程思想，面相对象是让代码更接近现实世界，将事物抽象成对象，关注对象之间的交互，更易于理解和扩展

- 封装，对内保护实现易于维护，对外只需关注交互

- 继承，模仿现实迭代，提供代码复用和层次结构

- 多态，代码灵活与扩展

  - 重载，同一个类中，方法名字相同，参数列表不同

- 重写，子类或者父类，方法名字相同，参数列表相同

- java多态，同样的操作 作用于不同的对象，有不同的解释或执行结果

- java运行时多态，重写；继承可以重写，实现必须重写

- java编译时多态，重载

- java高扩展，主要由两种途径，实现与继承（猜测，这也是jdk动态代理走实现，字节码走继承，两条路子 同样的设计理念）

- 同样可行情况下，优先组合（松耦合），而不是继承（强耦合）

- 不支持多继承，因为徒增复杂，且会有菱形继承问题

- java bean，不要写isSuccess，而要写success，首先对应的 getSuccess()更契合规范 getXxx()，其次很多IDE会将isSuccess自动生成isSuccess()方法而不是 getIsSuccess()，序列化的时候就会对应不上出问题了

- equals()底层默认就是==，只要引用指向同一个对象，就是相等

- hashcode()

- equals()和hashcode()相辅相成，两个对象相等的严格定义是 对象内容equals()相等 并且 哈希值hashcode()也要相等

- 对于散列集合（hashmap、hashset、hashtable）重写前者务必重写后者，否则无法按照预期工作；比如hashmap可能会导致相等的对象有不同的hashcode

  ```
  class Person {
      String name;
      int age;
  
      @Override
      public boolean equals(Object obj) {
          // 比较name和age是否相等
      }
      // 未重写hashCode
  }
  
  Person p1 = new Person("Alice", 30);
  Person p2 = new Person("Alice", 30);
  
  // 假设p1.equals(p2)为true，但p1.hashCode() != p2.hashCode()
  Set<Person> set = new HashSet<>();
  set.add(p1);
  set.contains(p2); // 返回false，因为哈希码不同，无法命中桶
  ```
  
- 浅拷贝，clone

- 深拷贝，序列化

- 值传递，

- 引用传递

- java平台无关性，源代码->前端编译->.class中间码->后端编译->机器语言；三个重要支撑，java语言规范，class文件，jvm虚拟机

- 对Integer.MIN_VALUE进行 abs会越界，所以先转long，再abs，降低概率

- long超过17位数前端numeric接收有缺失精度问题，可以全局拦截tostring

- 集合容器要求元素必须是Object，所以需要包装类

- 自动装箱：Integer a = 10；原理是 Integer a = Integer.valuesOf(10)；其他一样的 xxx.valueOf()

- 自动拆箱：int b = a；原理是 int b = a.intValue；其他一样的 .XxxValue()

- 自动拆装箱场景：基本类型放入集合、基本与包装类比较、包装类运算、三目运算符、函数返回与返回值

- 部分包装类是有缓存的（float和double范围太大且精度复杂无法高效缓存），可以避免频繁创建和销毁小范围对象，节省内存；Integer的范围可以通过jvm参数修改；自动拆装箱会有npe问题，如果在for循环中会浪费大量资源

  ```
  Integer a = 127;
  Integer b = 127;
  System.out.println(a == b);  // true（缓存范围内，对象复用）
  
  Integer c = 128;
  Integer d = 128;
  System.out.println(c == d);  // false（超出缓存范围，新建对象）
  
  Float f1 = 1.0f;
  Float f2 = 1.0f;
  System.out.println(f1 == f2);  // false（Float无缓存，每次新建对象）
  ```

  

- POJO中、RPC使用包装类，因为包装出错是null，null就是null；基本类型会是默认值具有二义性

## 异常

## 时间处理

## 语法糖

## 新版本特性

## jvm
 - java是编译型也是解释型，javac是编译过程，jvm对class文件解释执行，热点代码也会通过JIT及时编译执行
 - JIT，将热点代码直接翻译成机器码，并优化缓存起来
 - kill -9，强杀，kill -15 安全干净的退出（资源释放、临时文件清理等）
 - 运行时数据区-程序计数器，线程私有，当前执行字节码位置以及下一个字节码指令
 - 运行时数据区-栈，线程私有，当前线程的栈帧，局部变量、方法出口等
 - 运行时数据区-堆，共享区域，存放实例对象和字符串常量池
 - 运行时数据区-本地方法栈，线程私有，存放本地方法操作底层
 - 运行时数据区-方法区，共享区域，类信息、常量、静态变量，jit编译后的代码，运行时常量池
 - 字符串常量池是运行时常量池的逻辑子部分
 - jvm对象分配，逃逸分析后的栈上分配，堆内的tlab分配，一般eden区，满足晋升条件直接进入老年代
 - 堆分代，新生代1/3（eden80%，s0、s1），老年代2/3
 - survivor分俩是因为考虑到新生代需要复制算法，为了空间考虑，不能让一半的空间都闲着，所以需要两个
 - youngGC触发条件，年轻代的eden满了
 - fullGC触发条件，老年代不足、空间分配担保不足（晋升时老年代空间不充足）、永久代不足、System.gc()
 - stw，执行垃圾回收算法时，java进程中所有其他线程被挂起
 - stw频率，一天一次都算可以了比较多了，需要实际根据服务程度估算
 - 垃圾回收算法，标记-清除（空间利用足但产生内存碎片）、标记-复制（无空间碎片但浪费空间总有一半空着）、标记-整理（结合前两者优点，效率差）、
 - 垃圾标记算法（判断对象存活），引用计数法（查看对象被引用次数，效率高但是解决不了循环引用问题）、根可达算法（从一系列gcroot开始搜索，没有任何引用的就是垃圾，stw时间长）、三色标记法（解决前两种循环引用和stw问题）
 - GC Root，系统类加载器加载的对象、活着的线程、被sync锁着的对象
 - 三色标记法，白黑灰，初始标记（stw）、并发标记、重新标记（stw），并发标记阶段最耗时，能和应用线程并发执行，大大降低了stw总时长；通过写屏障，优化标记过程的准确性；
 - 三色标记问题-多标，错误标记处成了存活对象，产生浮动垃圾，不会太多，下次也能清理掉
 - 三色标记问题-漏标，本该存活没有标记被错误的回收了，cms采用增量更新方案解决，g1采用原始快照方案解决
 - 增量更新，黑对象新增对白对象引用时，重新扫描确保白被标记，稍微增加开销换取可靠
 - 原始快照，标记开始排个快照，
 - 强引用（绝不回收）、软引用（内存不够回收）、弱引用（扫到就回收）、虚引用（主要用于跟踪对象被回收的状态，在对象被回收之后进行一些后续处理）
 - 分代算法，新生代（标记-复制，适当放弃空间，追求效率）、老年代（标记-整理，追求空间和稳定）
 - 垃圾回收器-，
 - 垃圾回收器-，
 - 垃圾回收器-，
 - 垃圾回收器-，
 - 垃圾回收器-，
 - 垃圾回收器-，
 - 类生命周期，加载（加载、链接、初始化）、使用（初始化引用或者反射）、卸载（所有实例被回收或者classloader被回收）
 - 类加载过程，加载、链接（验证、准备、解析）、初始化
 - 符号引用，
 - 直接引用，
## 集合

## io

## 并发编程

- jmm，（是什么）定义了java线程如何在共享内存中交互的规范；（如何实现）主内存与工作内存交互机制；同步策略（有啥用）并发编程三大问题：线程安全、性能、资源分配，jmm就是建立了一套内存交互规范以及
- jmm实现内存可见性与原子性、volatile保证变量可见性和禁止指令重排、sync提供互斥和可见性
- sync 作用于两种，方法，和方法块；锁的是对象；非静态锁当前实例对象，静态锁类对象
- 线程安全，并发、多线程、共享变量、正确完成
- 
